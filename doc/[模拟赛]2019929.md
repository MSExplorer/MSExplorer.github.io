# [模拟赛]2019/9/29

## T1 迷宫

给定一个迷宫，迷宫中有一些障碍和一些记录点，你需要在不经过障碍的情况下，按顺序依次经过每个记录点（不能提前经过），若有解则求出最小的步数，否则输出 $-1$。

### 输入格式： 
第一行三个整数 $N，M，K$，表示迷宫的大小为 $N\times M$,有 $K$ 个记录点。
### 输出格式： 
共一行，一个整数 $ans$，表示最小的步数或无解。
### 样例输入： 
```
3 3 2
0 0 0
0 1 0
0 0 0
3 3
3 1
1 1
```
### 样例输出： 
```
6
```
### 数据范围： 
对于 $10\%$ 的数据，$N,M\leq 4$，$K\leq 1$。
对于 $30\%$ 的数据，$N,M\leq 10$。
对于 $60\%$ 的数据，$N,M\leq 100$。
对于 $100\%$ 的数据，$N,M\leq 1000$，$K\leq 10$。
### 时间限制： 
$1S$
### 空间限制： 
$512M$

## 题解

直接广搜 $k$ 次就行了。但是我太菜了，连广搜都写错。打标记要在入队之前打，不然还会被其他点扩展。

## 代码

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int N=1005;
int a[N][N],n,m,k,s[N][N],x[15],y[15],ans;
int tx[4]={0,0,-1,1};
int ty[4]={1,-1,0,0};
bool vis[N][N];
struct XY{
    int x,y;
};
queue<XY> q;
 
bool check(int nx,int ny,int i){
    if (nx<1 || ny<1 || nx>n || ny>m || vis[nx][ny] || (a[nx][ny]>0 && (nx!=x[i] || ny!=y[i]))) return false;
    return true;
}

int main(){
    scanf("%d%d%d",&n,&m,&k);
    for (int i=1;i<=n;++i)
        for (int j=1;j<=m;++j) scanf("%d",&a[i][j]);
    for (int i=1;i<=k;++i){
        scanf("%d%d",&x[i],&y[i]);
        a[x[i]][y[i]]=2;
    }
    scanf("%d%d",&x[0],&y[0]);
    for (int i=0;i<k;++i){
        for (;!q.empty();q.pop());
        s[x[i]][y[i]]=0;
        memset(vis,0,sizeof vis);
        vis[x[i]][y[i]]=1;
        bool flag=false;
        q.push((XY){x[i],y[i]});
        while (!q.empty()){
            if (flag) break;
            int nx=q.front().x,ny=q.front().y; q.pop();
            for (int j=0;j<4;++j){
                int xx=nx+tx[j],yy=ny+ty[j];
                if (!check(xx,yy,i+1)) continue;
                q.push((XY){xx,yy}); vis[xx][yy]=1;//要在入队时打标记，如果出队时再打可能会被其他点重复扩展TLE
                s[xx][yy]=s[nx][ny]+1;
                if (xx==x[i+1] && yy==y[i+1]){
                    ans+=s[xx][yy]; flag=true;
                    break;
                }
            }
        }
        if (!s[x[i+1]][y[i+1]]){
            printf("-1");
            return 0;
        }
    }
    printf("%d",ans);
    return 0;
}
```



## T2 过路费
有一天你来到了一个奇怪的国家，它有 $N$ 个城市，城市之间有若干条双向道路连接，每条道路都有一定的费用，经过城市也要一定的费用。从一个城市到达另一个城市的总花费为路径上费用最大的城市费用（包括起点和终点）加上路径上所有的道路的费用。给出 $Q$ 次询问，分别回答每次询问中两城市间的最少花费。保证城市之间可以互达。
### 输入格式： 
第一行两个整数 $N,M$，表示有 $N$ 个城市 $M$ 条道路。
### 输出格式： 
共 $Q$ 行每行一个整数，第 $i$ 行的整数表示第 $i$ 次询问的答案。
### 样例输入： 
```
3 3
1
3
2
1 2 1
2 3 1
1 3 3
2
1 3
1 3
```
### 样例输出： 
```
5
5
```
### 数据范围： 
对于 $30\%$ 的数据，$N\leq 10$，$M\leq 20$，$Q\leq 5$。
对于 $60\%$ 的数据，$N\leq 200$，$M\leq 4000$，$Q\leq 100$。
对于 $100\%$ 的数据，$N\leq 300$，$M\leq 40000$，$Q\leq 100000$，$1\leq c_i\leq 100000$，$1\leq z \leq 1000$。
### 时间限制： 
$2S$
### 空间限制： 
$512M$

## 题解

这道题改进一下 $Floyd$ 就行了，把点按照点权排序，最外层枚举时经过的最大点权就是第 $k$ 大的点，求出任意两点的最小花费。但是题目**不保证有重边**要注意判重。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=305;
int n,m,f[N][N],a[N][N],q,c[N];
struct city{
    int id,c;
}b[N];

bool cmp(city x,city y){
    return x.c<y.c;
}

int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;++i) scanf("%d",&b[i].c),b[i].id=i,c[i]=b[i].c;
    sort(b+1,b+1+n,cmp);
    memset(a,0x3f,sizeof a);
    for (int i=1;i<=n;++i) a[i][i]=0;
    for (int i=1,x,y,z;i<=m;++i){
        scanf("%d%d%d",&x,&y,&z);
        a[x][y]=min(a[x][y],z);//注意判重边!!!
        a[y][x]=a[x][y];
    }
    memset(f,0x7f,sizeof f);
    for (int k=1;k<=n;++k){
        for (int i=1;i<=n;++i)
            for (int j=1;j<=n;++j){
                if (a[i][b[k].id]+a[b[k].id][j]<a[i][j]) a[i][j]=a[i][b[k].id]+a[b[k].id][j];
            }
        for (int i=1;i<=n;++i)
            for (int j=1;j<=n;++j)
                f[i][j]=min(f[i][j],a[i][j]+max(b[k].c,max(c[i],c[j])));
    }
    scanf("%d",&q);
    for (int i=1,x,y;i<=q;++i){
        scanf("%d%d",&x,&y);
        printf("%d\n",f[x][y]);
    }
    return 0;
}
```



## T3 上课
学校里有许多节课，第 $i$ 节课从 $t_i$ 时刻开始上，上课的时间为 $s_i$，如果上了第 $i$ 节课，你的做题能力将变成 $c_i$ （是能力的数值，不是能力的增长值）。有 $N$ 类作业，每类作业数量不限，每类作业完成一份所需要的时间为 $a_i$，做某类作业需要的做题能力达到 $q_i()>=q_i)$ 才能完成。在每个时刻你可以选择上课、休息、做作业，如果选择上课则必须上完整节课，如果选择做作业必须花完整的 $a_i$ 时间做，同一时刻只能上一节课或做一份作业。而且人的精力有限，在 $T$ 时刻后必须停止学习（部分课可能上到 $T$ 时刻后）。求在时限内最多可以完成几份作业。在刚开始时，你的做题能力为 $1$，时刻为 $1$。
### 输入格式：
第一行三个整数 $T,M,N$，表示总时间，有M节课，有N类作业。
接下来M行每行三个整数 $t_i,s_i,c_i$。
接下来N行每行两个整数 $a_i,q_i$。
### 输出格式：
共一行，一个整数 $ans$，表示时限内最多可以完成几份作业。
### 样例输入：
```
10 1 2
3 2 5
4 1
1 3
```
### 样例输出：
```
6
```
### 数据范围：
$20\%$的数据满足 $M,N\leq 4$,$T\leq 15$。
$50\%$的数据满足 $M\leq 100$,$N\leq 1000$，$T\leq 1000$。
$100\%$的数据满足 $M\leq 1000$，$N\leq 100000$，$T\leq 100000$，$1\leq c_i\leq 100$，$1\leq a_i,t_i\leq T$，$1\leq q_i\leq 100$。
### 时间限制：
$1S$
### 空间限制：
$64M$

## 题解

$dp$ ，先把课程按照开始时间排序，设 $f[i]$ 表示上了第 $i$ 节课最多能做多少作业。贪心一下，需要同样能力的作业肯定是做时间最短的，所以还要预处理出 $cost[i]$ 表示做能力值小于等于 $i$ 的作业所需的最短时间。状态转移方程为：
$$
f[i]=min\{f[j]+(t[i]-(t[j]+s[j]-1)-1)\div cost[j]\}
$$
最终答案为 $f[m+1]$，但是要注意一下边界，$t[m+1]=T+1$ ，因为实际上没有第 $m+1$ 节课；$t[0]=1$ ，因为从时刻 $1$ 开始；$c[0]=1$ 刚开始做题能力为 $1$。

## 代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int M=1005;
int T,m,n,f[M],c[105];
struct lesson{
    int t,s,c;
}a[M];

bool cmp(lesson x,lesson y){
    return x.t==y.t?x.s<y.s:x.t<y.t;
}

int main(){
    scanf("%d%d%d",&T,&m,&n);
    for (int i=1;i<=m;++i) scanf("%d%d%d",&a[i].t,&a[i].s,&a[i].c);
    sort(a+1,a+1+m,cmp);
    memset(c,0x7f,sizeof c);
    for (int i=1,x,y;i<=n;++i){
        scanf("%d%d",&x,&y);
        c[y]=min(c[y],x);
    }
    for (int i=1;i<=100;++i) c[i]=min(c[i],c[i-1]);
    a[0]=(lesson){1,0,1}; a[m+1]=(lesson){T+1,0,0};
    for (int i=1;i<=m+1;++i)
        for (int j=0;j<i;++j)
        f[i]=max(f[i],f[j]+(a[i].t-(a[j].t+a[j].s-1)-1)/c[a[j].c]);
    printf("%d",f[m+1]);
    return 0;
}
```

