# [模拟赛]2019/9/27
## T1 除草
OI太可怕了，我决定回家去农场。
田野，安静的夜晚，微风，星空，银河穿越天空，一个人拿着方向盘，这种情况对于那些在大自然中没有感情的人来说是罕见的，而且会有很多人天生就有“每个人，我和一切都是一体”的感情。“在我的一生中，我希望每个人都有更多的时间来思考周围的奇迹，尽管他们在日常生活中忙碌生活就像一个穿越天空的流星。如果你不能在短短几十年内掌握存在的真正含义，你就不能称它为“活着”，你只能说“没有死亡”。
一阵寒风吹过，我从思绪中醒来，发现我已经驱赶了除草机而且我不知道我去了哪里。我从原点开始，我清楚地记得我的旋转角度和距离。我的除草机是相对高端的，旋转方向是在相同的位置完成的。
众所周知，我的智商非常低。
我想知道我在哪里。

### 输入：
第一行包含一个正整数 $N$，表示我改变方向的次数
接下来的 $N$ 行，每行包含两个实数 $A_i$ 和 $B_i$ 。这意味着我逆时针转动 $A_i$ 角，并以 $B_i$ 单位长度沿此方向行进。从 $(0,0)$ 开始，它开始面向 $X$ 轴的正方向。
### 输出：
只有一行，包含两个实数，分别是最终位置的 $X$ 和 $Y$ 坐标，保留 $2$ 个小数位，用空格分隔。
### 样本输入：
```
2
90 1
-90 1
```
### 样本输出：
```
1.00 1.00
```
### 数据范围：
对于 $100\%$ 的数据，$0<N\leq 500,000$，$0<B_i\leq 100$，$abs(A_i)\leq 180$
### 时限：
$1S$


### 空间限制：
$128M$

### 题解

这题很简单，只要把角度记下来直接模拟就行了。但要注意精度

### 代码

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
const double pi=3.1415926535898,eps=1e-8;
int n;
double x,y,a;
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;++i){
        double ag,dis;
        scanf("%lf%lf",&ag,&dis);
        a+=ag;
        double si=sin(pi*a/180.0),co=cos(pi*a/180.0);
        double ty=si*dis,tx=co*dis;
        x+=tx,y+=ty;
    }
    printf("%.2lf %.2lf",x+eps,y+eps);//要注意精度，不然可能输出-0.00
    return 0;
}
```

## T2 种花flower
​    OI太可怕了，我决定回家种田。
​    我在后院里开辟了一块圆形的花圃，准备种花。种花是一种艺术，通过一定技术手法，花材的排列组合会让花变得更加的赏心悦目，这就是花艺。
​      当然你知道，我在种田之前是OIer，所以我不懂花艺，只会排列组合。我把花圃从圆心向外画线，分成了N块扇形，分别编号为 $1，2，3.....N$，再从村里的商店采购了 $M$ 种花。然后我大胆的决定：花圃中的每块只种 $M$ 种花中的一种，相邻的两块不能种同一种花。我反应比较慢，所以我请来了机房里手速最快的强袭黯灭勋章鱼人守卫来帮我，让他试一下每种排列，看看哪种最令人赏心悦目。
​    有一些人，他们的美丽就在身边，也许就在自己身上，像艺术家一样，他们的眼光独到特别，可就因为他们不是艺术家，他们不被人们认可，被称之为另类。简单真实的事情总可以绽放最鲜艳的花，我欣赏这样的人的心理，当然拒绝粗鲁地对待一切。
​    正想着，他居然告诉我已经尝试完了。这怎么可能？这可一共有.......多少种方案来着？
​    众所周知的是，我的智商很低。
​    我想知道种花的方案一共有几种。
### 输入格式： 
仅一行，包含两个整数，分别为 $N$ 和 $M$。
### 输出格式： 
仅一行，包含一个整数，表示方案数。这个数可能很大，你只需要输出这个数对 $1e9+7$ 取模的结果。
### 样例输入： 
```
3 3
```
### 样例输出： 
```
6
```
### 数据范围： 
对于 $20\%$ 的数据，$0<N\leq 5$，$1<M\leq 5$
对于 $60\%$ 的数据，$0<N\leq 500,000$
对于 $100\%$ 的数据，$0<N\leq 10^18$，$1<M\leq 10^9$
### 时间限制： 
$1S$
### 空间限制： 
$128M$

### 题解
看这个数据范围应该是有公式的。题意是在一个有 $n$ 个点的环上染 $m$ 种颜色，相邻两个点颜色不同。
如果这是一条链答案显然是 $m\times (m-1)\times (m-1) ...\times(m-1)$ ，即 $m(m-1)^{n-1}$ ，但是最后一个点的颜色可能和第一个点颜色相同，我们把它们看成同一个点，设 $f(i)$ 表示 $i$ 个点组成的环染 $m$ 种颜色的答案，则 $f(n)=m(m-1)^{n-1}-f(n-1)$ ,再把式子展开： 
$$
f(n)=m(m-1)^{n-1}-m(m-1)^{n-2}+m(m-1)^{n-3}-m(m-1)^{n-4}......
$$

这就是一个等比数列！
$$
(m-1)f(n)=m(m-1)^n-m(m-1)^{n-1}+m(m-1)^{n-2}-m(m-1)^{n-3}......
$$
两式相加得到 $f(n)=(m-1)^n\pm(m-1)$ 注意因为 $n$ 的奇偶性，最后一项可能是加或减，代码就很简单了。

### 代码

```cpp
#include<cstdio>
using namespace std;
const int Mod=1e9+7;
long long n,m;
 
long long qpow(long long x,long long k){
    long long ans=1;
    for (;k;k>>=1){
        if (k&1) ans=(ans*x)%Mod;
        x=x*x%Mod;
    }
    return ans;
}
 
int main(){
    scanf("%lld%lld",&n,&m);
    if (n==1){
        printf("%lld",m);
        return 0;
    }
    if (n&1) printf("%lld",(qpow(m-1,n)-m+1+Mod)%Mod);
        else printf("%lld",(qpow(m-1,n)+m-1)%Mod);
    return 0;
}
```

## T3

这题其实就是[P3084 [USACO13OPEN]照片Photo](https://www.luogu.org/problem/P3084)

可以用差分约束，但是好像卡 $SPFA$ (反正我也不会)。用 $dp$ 也可以。

设 $f[i]$ 表示从第一头牛到第 $i$ 头牛（包括第 $i$ 头且第 $i$ 头一定是）中最多有几头斑点奶牛。

$f[i]=max\{f[j]\}+1,\ j\text{符合条件}$ 因为每张照片中有且仅有一头， $j$ 符合条件需满足 $j<i$ 且 $j$ 和 $i$ 不在同一张照片中。

设 $l[i],r[i]$ 表示对于 $i$ 符合条件的 $j$ 的范围，即 $r[i]$ 表示包含 $i$ 的照片中最小的左端点$-1$；$l[i]$表示在 $i$ 之前的区间最大的左端点。

最后 $dp$ 时可以用单调队列优化，降低复杂度。

### 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<deque>
using namespace std;
const int N = 2e5 + 5;
int n, m, l[N], r[N], f[N];
deque<int> q;
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n + 1; ++i) r[i] = i - 1;//初始化
    for (int i = 1, x, y; i <= m; ++i) {
        scanf("%d%d", &x, &y);
        r[y] = min(r[y], x - 1);//可以方便算出又端点的r
        l[y + 1] = max(l[y + 1], x);
    }
    for (int i = n; i; --i) r[i] = min(r[i], r[i + 1]);//计算每个点的r[i]
    for (int i = 2; i <= n + 1; ++i) l[i] = max(l[i], l[i - 1]);//计算每个点的l[i]
    int j = 1; q.push_back(0);
    for (int i = 1; i <= n + 1; ++i) {
        for (; j <= r[i] && j <= n;) {//把符合条件的点加入单调队列
            if (f[j] == -1) { j++; continue; }
            for (; !q.empty() && f[q.back()] < f[j]; q.pop_back());
            q.push_back(j++);
        }
        for (; !q.empty() && q.front() < l[i]; q.pop_front());
        if (q.size()) f[i] = max(f[i], f[q.front()] + (i<=n?1:0));
        else f[i] = -1;
    }
    //for (int i = 1; i <= n; ++i) printf("%d ", f[i]);
    printf("%d", f[n + 1]);
    return 0;
}
```

