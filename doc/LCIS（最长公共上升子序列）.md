# LCIS（最长公共上升子序列）

## 题目

熊大妈的奶牛在小沐沐的熏陶下开始研究信息题目。

小沐沐先让奶牛研究了最长上升子序列，再让他们研究了最长公共子序列，现在又让他们研究最长公共上升子序列了。

小沐沐说，对于两个数列 $A$ 和 $B$，如果它们都包含一段位置不一定连续的数，且数值是严格递增的，那么称这一段数是两个数列的公共上升子序列，而所有的公共上升子序列中最长的就是最长公共上升子序列了。

奶牛半懂不懂，小沐沐要你来告诉奶牛什么是最长公共上升子序列。

不过，只要告诉奶牛它的长度就可以了。

数列 $A$ 和 $B$ 的长度均不超过 $3000$。

#### 输入格式

第一行包含一个整数 $N$，表示数列 $A$，$B$ 的长度。

第二行包含 $N$ 个整数，表示数列 $A$。

第三行包含 $N$ 个整数，表示数列 $B$。

#### 输出格式

输出一个整数，表示最长公共子序列的长度。

#### 数据范围

$1≤N≤3000$,序列中的数字均不超过 $2^{31}-1$

#### 输入样例：

```
4
2 2 1 3
2 1 2 3
```

#### 输出样例：

```
2
```

## 做法

结合最长公共子序列 $(LCS)$ ，和最长上升子序列 $(LIS)$ ，可以设 $f[i][j]$ ，表示 **$A$ 中前 $i$ 个数和 $B$ 中前 $j$ 个数中以 $B[j]$ 结尾的最长公共上升子序列长度** 。那么转移方程就是
$$
f[i][j]=f[i-1][j]\quad (A[i]\ne B[j])\\
f[i][j]=\max\limits_{0\leq k < j}\{f[i-1][k]\}+1\quad (A[i]==B[j]\  \text{&&}\ B[k]<A[i])
$$

#### 代码

```cpp
for (int i=1;i<=n;++i)
    for (int j=1;j<=n;++j)
        if (a[i]==b[j]){
            for (int k=0;k<j;++k)
                if (b[k]<a[i]) f[i][j]=max(f[i][j],f[i-1][k]+1);
        }else f[i][j]=f[i-1][j];
```

但是这样做复杂度是 $n^3$ 的，会超时，我们考虑优化一下。

对于每一个 $i$ ，在枚举 $j$ 从 $1$ 增加到 $n$ 时，$k$ 的范围也只增加了 $1$ 。我们可以用一个变量记录 $k=0$ 时的最大值，当 $j$ 增加时，我们不用枚举 $k$ ，只需用 $k=j$ 时的最大值更新那个变量即可。

#### 代码

```cpp
for (int i=1;i<=n;++i){
    int val=0;//val记录f[i-1][k]的最大值
    if (b[0]<a[i]) val=f[i-1][0];//j=1时k可以取0
    for (int j=1;j<=n;++j){
        if (a[i]==b[j]) f[i][j]=val+1;
    		else f[i][j]=f[i-1][j];
        if (b[j]<a[i]) val=max(val,f[i-1][j]);//j即将增大为j+1,检查j能否进入决策集合
    }
}
```