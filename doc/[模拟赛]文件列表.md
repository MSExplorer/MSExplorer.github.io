# [模拟赛]文件列表

BSOI在线评测机被不明身份的人入侵了！！系统中大量的数据遭到恶意破坏，数据文件残缺不全。现在，老师正在尽力抢救数据文件。为了检查数据文件是否完整，老师打印出了所有文件的列表，但数据文件太多，老师眼睛都要看花了。所以，为了方便老师检查，需要你写个程序处理一下文件列表，转换成下面这样统一的格式：(//后面为注释)
```
data //data文件夹,根目录
|----prob //data下面的文件夹
|　　|----a.in //prob下面的文件
|　　|----a.out
|----qq //data下面的文件夹
|　　|----new //qq下面的文件夹
|　　|　　|----ok.txt //new下面的文件
|　　|----old //空文件夹
|----xxx.rmvb
```
生成的列表格式有如下要求:
1. 属于同一层的文件或文件夹位于相同的缩进处，相邻两层文件间差距 $5$ 个字符；
2. 每个文件夹或文件前有 $4$ 个'-'(根目录除外)，文件夹下方属于文件夹的部分有'|'；
3. 属于同一文件夹下的文件或子文件夹按字典序排列；

### 输入格式： 

第一行一个整数 $n$ $(n\leq 50)$，表示总共的文件数目；

### 输出格式： 

输出符合要求的文件列表

### 样例输入： 

```
5
mydoc/abcd/abc.txt
mydoc/dd/libexec.a
mydoc/stdio.h
mydoc/abcd/zzz/game.cpp
mydoc/abcd/new
```

### 样例输出： 

```
mydoc
|----abcd
|    |----abc.txt
|    |----new
|    |----zzz
|    |    |----game.cpp
|----dd
|    |----libexec.a
|----stdio.h
```

### 数据范围： 

对于 $30\%$ 的数据,根目录下只有文件，没有文件夹



这种字符串处理模拟题，总令人觉得很烦，调半天调不出来，其实仔细想想，想好了再写，这种题目还是挺简单的。

我本来的想法是根据目录建一颗树，最后 $dfs$ 一下就好了，于是马上开始写，没有仔细考虑如何实现和细节处理，结果写了半天，调了半天，最后被一组数据无情的卡掉了。

```
2
c/a/b
c/b/a
```

##### 丑陋的代码

~~又臭又长~~

```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
const int Mod=99991;
int n,cnt,id[Mod+1];
char s[205],name[2005][205];
unsigned long long p[50];
bool vis[100005][10];
vector<int> ch[Mod+10];
vector<unsigned long long> v[Mod+10];
 
bool cmp(int x,int y){
    int l1=strlen(name[id[x]]+1),l2=strlen(name[id[y]]+1);
    int len=min(l1,l2);
    for (int i=1;i<=len;++i)
        if (name[id[x]][i]!=name[id[y]][i]) return name[id[x]][i]<name[id[y]][i];
    return l1<l2;
}
 
void Hash(int num){
    int len=strlen(name[num]+1);
    unsigned long long val=0;
    for (int i=1;i<=len;++i)
        val+=name[num][i]*p[i-1];
    int t=val%Mod;
    id[t]=num;
    for (int i=0;i<v[t].size();++i) if (v[t][i]==val) return;
    v[t].push_back(val);
}
 
int find(int num){
    int len=strlen(name[num]+1);
    unsigned long long val=0;
    for (int i=1;i<=len;++i)
        val+=name[num][i]*p[i-1];
    int t=val%Mod;
    return t;
}
 
void dfs(int x,int dep){
    //printf("%d %d\n", x, dep);
    vis[x][dep]=1;
    for (int i=1;i<dep;++i) printf("|    ");
    if (dep!=0) printf("|----");
    printf("%s\n",name[id[x]]+1);
    if (!ch[x].size()) return;
    sort(ch[x].begin(),ch[x].end(),cmp);
    for (int i=0;i<ch[x].size();++i){
        if (vis[ch[x][i]][dep+1]) continue;
        dfs(ch[x][i],dep+1);
    }
    for (int i=0;i<ch[x].size();++i)
        for (int j=0;j<=5;++j) vis[ch[x][i]][j]=0;
}
 
int main(){
    scanf("%d\n",&n);
    p[0]=1;
    for (int i=1;i<50;++i) p[i]=p[i-1]*131;
    for (int i=1;i<=n;++i){
        gets(s+1);
        int len=strlen(s+1),lst=1,lat=cnt+1;
        for (int j=1;j<=len;++j){
            if (s[j]=='/'){
                cnt++;
                for (int k=lst;k<=j-1;++k) name[cnt][k-lst+1]=s[k];
                Hash(cnt);
                // printf("%s\n",name[cnt]+1);
                lst=j+1;
            }
            if (j==len){
                cnt++;
                for (int k=lst;k<=j;++k) name[cnt][k-lst+1]=s[k];
                Hash(cnt);
                // printf("%s\n",name[cnt]+1);
            }
        }
        for (int i=lat;i<cnt;++i) ch[find(i)].push_back(find(i+1));
    }
    // for (int i=1;i<=cnt;++i){
    //     int x=find(i);
    //     if (!vis[x]) dfs(x,0);
    // }
    dfs(find(1),0);
    // printf("Error!");
    return 0;
}
/*
data //data文件夹,根目录
|----prob //data下面的文件夹
|　　|----a.in //prob下面的文件
|　　|----a.out
|----qq //data下面的文件夹
|　　|----new //qq下面的文件夹
|　　|　　|----ok.txt //new下面的文件
|　　|----old //空文件夹
|----xxx.rmvb
*/
```



其实仔细想想，不用这么麻烦，把每个字符串的前缀排序，就是输出的顺序，其他的简单到看代码就行了……

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,cnt;
char s[55];
struct String{
    char s[55];
}a[1005],b[1005];

bool cmp(String x,String y){
    int l1=strlen(x.s+1),l2=strlen(y.s+1);
    int len=min(l1,l2);
    for (int i=1;i<=len;++i)
        if (x.s[i]!=y.s[i]) return x.s[i]<y.s[i];
    return l1<l2;
}

int main(){
    scanf("%d\n",&n);
    for (int i=1;i<=n;++i){
        gets(s+1);
        int len=strlen(s+1);
        for (int j=1;j<=len;++j){
            if (s[j]=='/'){
                cnt++;
                for (int k=1;k<j;++k) a[cnt].s[k]=s[k];
            }
            if (j==len){
                cnt++;
                for (int k=1;k<=j;++k) a[cnt].s[k]=s[k];
            }
        }
    }
    sort(a+1,a+1+cnt,cmp);
    n=0;
    for (int i=1;i<=cnt;++i)
        if (i==1 || strcmp(a[i].s+1,a[i-1].s+1)!=0){
            n++; int len=strlen(a[i].s+1);
            for (int j=1;j<=len;++j) b[n].s[j]=a[i].s[j];
        }
    printf("%s\n",b[1].s+1);
    for (int i=2;i<=n;++i){
        int sum=0,lst=1,len=strlen(b[i].s+1);
        for (int j=1;j<=len;++j)
            if (b[i].s[j]=='/') sum++,lst=j+1;
        for (int j=1;j<sum;++j) printf("|    ");
        printf("|----");
        for (int j=lst;j<=len;++j) printf("%c",b[i].s[j]);
        printf("\n");
    }
    return 0;
}
```

