# 2019/7/29[模拟赛]

## T1 基因光线

黑大帅统治古古怪界后，一直在玩一种很奇葩的游戏。在一个二维平面上，他先复制了 $n$ 个小 $A$，把他们放在不同的位置，然后射出一条 $ax+by+c=0$ 的基因光线，宽度为 $d$，即离这条直线的距离不大于 $d$ 的小 $A$ 会被射中。当然，某些悲剧的小 $A$ 就会被射中，并变成黑小 $A$ 。当然，这不是重点。玩了很久后，黑大帅猛然发现，自己竟然一次都没有射中小 $A$。黑大帅怒了，于是他开启了作弊模式，将 $c$ 改成自己想要的任意数值。现在，黑大帅想知道，在开启了作弊模式后，他射出一道基因光线最多能击中几个小 $A$。

### 输入格式： 

第一行五个数字 $a，b，d，n$，接下来 $n$ 行每行两个数字 $x，y$ 表示这个小A的坐标。

### 输出格式： 

一行一个数字表示最多能击中几个小 $A$。

### 样例输入： 

```
1 -1 0.707106782 5
0 0
1 0
0 1
2 0
2 1
```

### 样例输出： 

```
4
```

### 数据范围： 

$50\%$的数据满足 $a=0$ ;
$100\%$的数据满足 $n\leq100000$，其余所有数值均为绝对值不大于 $1000$ 的实数。

首先点到直线距离 $d=|\dfrac{ax+by+c}{\sqrt{a^2+b^2}}|$
我们可以先算出每个点到直线 $ax+by=0$ 的距离 $dis[i]$，因为斜率相同，如果 $|dis[i]-dis[j]|\leq 2\times d$ 说明  $i,j$ 可以同时被一条光线覆盖。我们可以对 $dis$ 数组排序，若 $dis[i]-dis[j]\leq 2\times d\quad (j<i)$ ，$ans=max(ans,i-j+1)$ 可以用类似单调队列的做法，$O(n)$ 算出答案。

### 代码

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int N=1e5+5;
int n,ans;
double a,b,d,dis[N];
deque<int> q;
int main(){
    scanf("%lf%lf%lf%d",&a,&b,&d,&n);
    for (int i=1;i<=n;++i){
        double x,y;
        scanf("%lf%lf",&x,&y);
        dis[i]=(a*x+b*y)/sqrt(a*a+b*b);
    }
    sort(dis+1,dis+1+n);
    d+=d;
    for (int i=1;i<=n;++i){
        for (;!q.empty() && dis[i]-dis[q.front()]>d;q.pop_front());
        if (!q.empty()) ans=max(ans,i-q.front()+1);
        q.push_back(i);
    }
    printf("%d",ans);
    return 0;
}
```



## T2 好朋友

$noip2011$就要来了，$W$校的同学们不仅看重这次比赛，更看重$noip2011$和谁住在同一个房间。同学之间的关系好坏可以用一个亲密值表示，亲密值越大，两个同学关系越好。小 $A$ 作为 $W$ 校信息组的组长，自然想要让同学们在比赛前能好好休息，放松心情，让同学们在赛场上能够超常发挥。他现在知道自己预订的房间都是双人间，且知道这 $n$ 个同学之间的关系。$n$ 个同学的关系可以用一个 $n$ 条双向边的连通图来描述，即某个同学只愿意和与他有边相连的同学住同一个房间，边权即为两个同学的亲密值。数据保证没有重边、自环。现在小 $A$ 想知道在让所有同学的要求满足的情况下，亲密值最低的一对同学亲密值最高是多少。

### 输入格式： 

第一行一个正整数 $n$，下面n行每行三个数 $u，v，w$，表示 $u$ 到 $v$ 有一条边权为 $w$ 的双向边。

### 输出格式： 

假如无论如何都无法满足所有同学的要求，输出”no answer”，否则输出亲密值最低的一对同学的最高亲密值。

### 样例输入： 

```
4
1 2 3
2 3 10
3 4 3
1 4 1
```

### 样例输出： 

```
３
```

### 数据范围： 

$50\%$的数据满足$n\leq 20$;
$80\%$的数据满足$n\leq 1000$;
$100\%$的数据满足$n\leq 100000$，$-10^9\leq w\leq 10^9$

最小值最大，就想到二分答案。二分最低的亲密度，把低于这个值的边断开。然后从度为 $1$ 的点开始，两两配对，最后判断可以配对有几个，有 $n$ 个则返回 $true$ ，否则返回 $false$。如果 $n$ 是奇数或二分时没有更新 $ans$ 就是 $no\ answer$。


还有一种贪心的做法，我没写过，不大懂……

 ### 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
const int N=1e5+5;
int n,head[N],to[N<<1],nxt[N<<1],edge[N<<1],tot,l=0x7f7f7f7f,r=-0x7f7f7f7f,d[N];
bool vis[N];

void add_edge(int x,int y,int z){
    to[++tot]=y; edge[tot]=z; nxt[tot]=head[x]; head[x]=tot;
}

queue<int> q;
bool check(int val){
    memset(d,0,sizeof d);
    memset(vis,0,sizeof vis);
    for (int i=1;i<=n;++i)
        for (int j=head[i];j;j=nxt[j])
            if (edge[j]>=val) d[i]++;
    for (int i=1;i<=n;++i) if (d[i]==1) q.push(i);
    if (q.empty()) return true;
    while (!q.empty()){
        int x=q.front(); q.pop();
        for (int i=head[x];i;i=nxt[i]){
            if (vis[to[i]] || edge[i]<val) continue;
            vis[to[i]]=vis[x]=1;
            for (int j=head[to[i]];j;j=nxt[j]){
                if (vis[to[j]] || edge[j]<val) continue;
                if (--d[to[j]]==1) q.push(to[j]);
            }
        }
    }
    int cnt=0;
    for (int i=1;i<=n;++i) if (vis[i]) cnt++;
    if (cnt==n) return true;
    return false;
}

int main(){
    scanf("%d",&n);
    for (int i=1,x,y,z;i<=n;++i){
        scanf("%d%d%d",&x,&y,&z);
        add_edge(x,y,z);
        add_edge(y,x,z);
        l=min(l,z); r=max(r,z);
    }
    if (n&1){
        printf("no answer");
        return 0;
    }
    int ans=0,flag=0;
    while (l<=r){
        int mid=(l+r)>>1;
        if (check(mid)) ans=mid,flag=1,l=mid+1;
            else r=mid-1;
    }
    if (!flag) printf("no answer");
        else printf("%d",ans);
    return 0;
}
```



-----

## T3 砍树(2)

小 $A$ 是小 $B$ 家的园丁。小 $B$ 的家里有 $n$ 棵树，第 $i$ 棵树的横坐标为 $i$。一天，小 $B$ 交给小 $A$ 一个任务，让他降低自己家中的某些树木的高度。这个任务对小 $A$ 来说十分简单，因为他有一把极其锋利的斧头和一门独门砍树秘籍，能够轻易地砍断任何参天大树。小 $A$ 的砍树方法有 $3$ 种，都是沿着一条 $y=kx+b$ 的直线砍一段区间的树，相同的方法 $k$ 值相同。只用了一个下午，小 $A$ 就完成了小 $B$ 的任务。第二天，小 $B$ 来视察小 $A$ 的任务完成情况。小 $B$ 想知道小 $A$ 是否真的用心砍树，于是提出了 $q$ 个询问，每次询问一段区间中最低的树的高度。小 $A$ 当然是不会记住树木的砍伐情况的，他只知道自己按什么顺序，使用了什么方法，砍了哪个连续区间的树，而且区间都是互不包含的。现在小 $A$ 想请你帮帮他，回答小 $B$ 的询问。

### 输入格式： 

第一行三个整数 $k1$， $k2$，$k3$ 表示小 $A$ 三种砍树方法的斜率值；

### 输出格式： 

一共 $q$ 行，每行一个数 $h$ 表示对应的回答。

### 样例输入： 

```
1 0 -1
4
10 30 20 1
2
3 4 2 5
1 3 3 10
2
1 2
2 3
```

### 样例输出： 

```
８
５
```

### 数据范围： 

$n\leq 10^6$, $m<=5\times 10^5$

这题可以用线段树来实现区间修改和查询，但是我太菜了，懒标记打不来，也不知道怎么维护。

有大佬有一种单调队列的做法。

因为题目中保证这些区间互不包含，这些区间应该是这样：
```
|_____________|
       |______________|
           |________________|
```
对于给定的斜率，要使 $y$ 最小，$b$ 也要尽量小。

例如三段区间的 $b$ 分别是 $3,1,4$
```
3|___x__|__________|
       1|______y______|
           4|_____y___|___z__|
```
$x$ 区间 $b$ 是 $3$，$y$ 区间 $b$ 是 $1$ ，$z$ 区间 $b$ 是 $4$。

单调队列维护最小的 $b$ ，若超出这个区间，就弹出队头，算出修改后每棵树的高度，最后只要区间查询最小值就行了，可以用线段树或 $ST$ 表。


### 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int N=1e6+5;
int k[4],n,m,a[N];
struct SegmentTree{
    int l,r,min;
}t[N*3];
struct change{
    int l,r,p,b;
}b[N];

template<typename T>
inline void read(T &x){
    char ch=getchar(); bool f=0; x=0;
    for (;ch<'0' || ch>'9';ch=getchar()) f^=(ch=='-');
    for (;ch>='0' && ch<='9';ch=getchar()) x=x*10+(ch^48);
    x=f?-x:x;
}

bool cmp(change x,change y){
    return x.l<y.l;
}
  
void build(int p,int l,int r){
    t[p].l=l; t[p].r=r;
    if (l==r){
        t[p].min=a[l];
        return;
    }
    int mid=(l+r)>>1;
    build(p<<1,l,mid);
    build((p<<1)+1,mid+1,r);
    t[p].min=min(t[p<<1].min,t[(p<<1)+1].min);
}
  
int ask(int p,int l,int r){
    // printf("%d %d %d\n",t[p].l,t[p].r,t[p].min);
    // spread(p);
    if (l<=t[p].l && r>=t[p].r) return t[p].min;
    int mid=(t[p].l+t[p].r)>>1;
    int ans=0x7f7f7f7f;
    if (l<=mid) ans=min(ans,ask(p<<1,l,r));
    if (r>mid) ans=min(ans,ask((p<<1)+1,l,r));
    return ans;
}

deque<change> q[4];
int main(){
    read(k[1]),read(k[2]),read(k[3]),read(n);
    for (int i=1;i<=n;++i) read(a[i]);
    read(m);
    for (int i=1;i<=m;++i) read(b[i].l),read(b[i].r),read(b[i].p),read(b[i].b);
    sort(b+1,b+1+m,cmp);
    for (int i=1,j=1;i<=n;++i){
        for (;j<=m && b[j].l<=i;++j){
            int cmd=b[j].p;
            for (;!q[cmd].empty() && b[j].b<q[cmd].back().b;q[cmd].pop_back());
            q[cmd].push_back(b[j]);
        }
        for (int t=1;t<=3;++t){
            for (;!q[t].empty() && q[t].front().r<i;q[t].pop_front());
            if (!q[t].empty()){
                change top=q[t].front();
                a[i]=min(a[i],k[top.p]*i+top.b);
            }
        }
    }
    build(1,1,n);
    read(m);
    for (int i=1,l,r;i<=m;++i){
        read(l),read(r);
        printf("%d\n",ask(1,l,r));
    }
    return 0;
}
```

