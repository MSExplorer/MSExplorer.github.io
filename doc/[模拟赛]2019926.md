# [模拟赛]2019/9/26

## T1 友好数对
如果一个数 $a$ 能由一个数 $b$ 旋转得到，那么我们称为友好数对，如 $12345$ 和 $45123$ 为友好数对，$12345$ 和 $54321$ 不为友好数对。给出两个正整数 $L$，$R$，求有多少友好数对,满足 $L\leq a $，且 $a\leq R$
### 输入格式：
第一行一个整数 $T$，表示数据组数，每组数据两个正整数 $L,R$。
### 输出格式：
对于每组数据，输出一个整数表示答案。
### 样例输入：
```
4
1 9
10 40
100 500
1111 2222
```
### 样例输出：
```
0
3
156
287
```
### 数据范围：
对于 $30\%$ 的数据满足 $L,R\leq 1000$
对于 $100\%$ 的数据满足 $L,R\leq 2000000$，$T<=30,L,R$位数相同。

### 时间限制：
$2S$
### 空间限制：
$256M$

### 题解

一看好像很简单，直接从 $L$ 到 $R$ 扫一遍枚举每个数旋转（把这个数的后一部分移到前面）后的数，判断是否满足题目条件，有没有重复即可。

### 代码

```cpp
#include<cstdio>
using namespace std;
int T,L,R,Pow[8];
  
int calc(int x){
    int cnt=0;
    for (;x;){
        x/=10; cnt++;
    }
    return cnt;
}
  
int main(){
    scanf("%d",&T);
    Pow[0]=1;
    for (int i=1;i<=7;++i) Pow[i]=Pow[i-1]*10;
    while (T--){
        scanf("%d%d",&L,&R);
        int n=calc(L),ans=0;
        for (int i=L;i<=R;++i){
            for (int j=1;j<n;++j){
                int now=(i%Pow[j])*Pow[n-j]+(i/Pow[j]);
                if (now==i) break; //一定要加这句话，因为i可能旋转后和原来相等，有些友好数对会被重复计算（不加就错了
                if (now>i && now>=L && now<=R) ans++;
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

## T2 路径数
Euphemia到一个 $N\times N$ 的药草田里采药，她从左上角的格子田（第一行，第一列）出发，要到达右下角（第 $N$ 行，第 $N$ 列）的格子田，每次她可以走到与当前格子有边相邻的格子去，但她不会走已经走过的格子，而且出于对美的要求，她走过的路径是关于  左下-右上  对角线对称的。由于地势不同，在每个格子田采药都会有一个疲劳度 $T_{i,j}$，Euphemia想知道：有多少条合法路径，可以使得她采药的疲劳度最小。
### 输入格式：
多组数据。
每组数据第一行一个整数 $N$ ，接下来 $N$ 行，每行 $N$ 个非零数字（$1,2,3...9$ 中一个），表示格子田的疲劳度。
当 $N=0$，输入结束。
### 输出格式：
对于每组数据，输出一个整数表示答案，答案 $\%1e9+9$。
### 样例输入：
```
2
1 1
1 1
3
1 1 1
1 1 1
2 1 1
0
```
### 样例输出：
```
2
3
```
### 数据范围：
对于 $20\%$ 的数据满足 $N\leq 5$。
对于另外 $20\%$ 的数据满足 $N\leq 40$。
对于 $100\%$ 的数据满足 $N\leq 100$,不超过 $50$ 组数据。
### 时间限制：
$1S$
### 空间限制：
$256M$

### 题解

因为走的路径是对称的，所以我们可以把图“对折”，最后只要做出起点到对角线上的最短路数即可。

统计最短路数可以开一个数组`cnt[i]`记录到这个点的最短路数，如果`edge[i]+dis[x]<dis[y]`，`cnt[y]=cnt[x]`，如果`edge[i]+dis[x]==dis[y]`，`cnt[y]+=cnt[x]`。

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
const int N=1e5+5,Mod=1e9+9;
int n,a[105][105],tot,head[N],to[N<<1],nxt[N<<1],val[N],dis[N],cnt[N];
bool vis[N];
   
void add_edge(int x,int y){
    to[++tot]=y; nxt[tot]=head[x]; head[x]=tot;
}
   
int tran(int x,int y){
    return (x-1)*n+y;
}
   
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
int main(){
    while (scanf("%d",&n) && n){
        memset(head,0,sizeof head);
        memset(cnt,0,sizeof cnt);
        tot=0;
        for (int i=1;i<=n;++i)
            for (int j=1;j<=n;++j) scanf("%d",&a[i][j]);
        for (int i=1;i<=n;++i)
            for (int j=1;j<=n;++j){
                int x=tran(i,j),dx=tran(i+1,j),rx=tran(i,j+1);
                if (i+j!=n+1) val[x]=a[i][j]+a[n-j+1][n-i+1];
                    else val[x]=a[i][j];
                if (i<n) add_edge(x,dx),add_edge(dx,x);
                if (j<n) add_edge(x,rx),add_edge(rx,x);
            }
        /*
        for (int i=1;i<=n;++i){
            for (int j=1;j<=n;++j){
                if (i+j!=n+1) printf("%d ",a[i][j]+a[n-j+1][n-i+1]);
                    else printf("%d ",a[i][j]);
            }
            printf("\n");
        }
        */
        memset(dis,0x3f,sizeof dis); dis[1]=val[1]; cnt[1]=1;
        memset(vis,0,sizeof vis);
        q.push(make_pair(0,1));
        while (!q.empty()){
            int x=q.top().second; q.pop();
            if (vis[x]) continue;
            vis[x]=1;
            for (int i=head[x];i;i=nxt[i]){
                int y=to[i];
                if (val[y]+dis[x]<dis[y]){
                    dis[y]=dis[x]+val[y]; q.push(make_pair(dis[y],y));
                    cnt[y]=cnt[x]%Mod;
                }else if (val[y]+dis[x]==dis[y]) cnt[y]=(cnt[y]+cnt[x])%Mod;
            }
        }
        int ans=0x7f7f7f7f,total=0;
        for (int i=1;i<=n;++i){
            int x=tran(i,n+1-i);
            if (dis[x]<ans) ans=dis[x];//,printf("! %d %d %d %d\n",i,n+1-i,dis[x],val[x]);
        }
        for (int i=1;i<=n;++i){
            int x=tran(i,n+1-i);
            if (dis[x]==ans) total=(total+cnt[x])%Mod;//,printf("dis[%d][%d]=%d cnt[%d][%d]=%d\n",i,n+1-i,dis[x]+val[x],i,n+1-i,cnt[x]);
        }
        printf("%d\n",total);
    }
    return 0;
}
```

## T3 选信封
Dumbulidone和Euphemia玩一个挑卡片游戏.
Dumbulidone会给出N对信封，每个信封里有两张不同颜色的卡片，她会让Euphemia从中挑选任意个信封，但是一对信封中最多只能挑选一个，（信封是透明的，可以看到里面卡片颜色）。等Euphemia挑好后，Dumbulidone会尝试从Euphemia挑出的信封中再选出若干个（不可以不取），把其中的卡片取出，若存在一种方案使得取出的卡片中，每种颜色的卡片都有偶数张，那么Dumbulidone就赢了。Euphemia想知道在自己赢的前提下，她最多能选出多少信封。
### 输入格式：
第一行一个整数 $N$。
接下来 $N$ 行，每行 $4$ 个整数，描述一对信封中卡片颜色，前两个是一个信封中的，后两个是一个信封中的。
### 输出格式：
一个整数，表示答案。
### 样例输入：
```
样例输入一
4
0 1 0 5
5 1 0 5
1 2 0 1
1 5 2 0
样例输入二
6
1 4 1 4
2 4 2 4
0 3 0 3
0 4 0 4
4 3 4 3
1 3 1 3
```
### 样例输出：
```
样例输出一
3
样例输出二
4
```
### 数据范围：
对于 $30\%$的数据满足 $N\leq 10$
对于$100\%$的数据满足 $N\leq 300$,所有数 $\leq 10^7$.
### 时间限制：
$1S$
### 空间限制：
$256M$

然而我不会，好像要用带花树……