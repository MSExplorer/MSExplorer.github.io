# [模拟赛]2019/10/06

## T1 小w与卡牌游戏

<p style="text-align: center;font-size: 18px;font-family: consolas">空间限制：512M  时间限制：1s</p>
### 【问题描述】
在昨天玩了数字游戏后，小 $w$ 觉得不过瘾，叫上了小 $c$ 一起来玩卡牌游戏。小 $w$ 和小 $c$ 各有 $n$ 张扑克牌，每张牌上都有一个数字。游戏共进行 $n$ 轮，每轮两人各会出一张扑克牌。对于每一轮，牌面上数字大的人获胜并获得一分。鉴于小 $w$ 是卡牌高手，所以他会让着小 $c$ 。因此如果两张牌面的数字相同，则小 $c$ 获胜。小 $w$之所以能成为卡牌高手，是因为它有很强的第六感。他可以通过心灵感应获取了小 $c$ 手上所有卡牌上的数字以及小 $c$ 的出牌顺序。通过这些信息，小 $w$ 可以安排自己的出牌顺序以获得尽量多的分数。小 $w$ 把这个任务交给了你，他想要知道一种出牌顺序，使得它的得分最多。特别地，如果有多种合法的出牌顺序，他希望出牌顺序的字典序最大。
### 【输入文件】
第一行一个整数 $n$ ，表示游戏的轮数。第二行 $n$ 个整数，表示小 $c$ 手上的卡牌 $c_i$ ，卡牌按出牌顺序依次给出。第三行 $n$ 个整数，表示小 $w$ 手上的卡牌 $w_i$。
### 【输出文件】
$n$ 个整数，表示得分最高且字典序最大的出牌顺序。
### 【输入样例1】
```
5
1 2 3 4 5
1 2 3 4 5
```
### 【输出样例1】
```
2 3 4 5 1
```
### 【输入样例2】
```
5
3 4 5 6 7
1 3 5 7 9
```
### 【输出样例2】
```
9 5 7 3 1
```
### 【数据规模和约定】
对于 $30\%$ 的数据，$n\leq 10$
对于另外 $20\%$ 的数据，数据保证只存在一种使小 $w$ 得分最高的方案
对于 $100\%$ 的数据，$n\leq 1000$ 数据保证 $1\leq c_i,w_i\leq 10^9$
### 【样例解释】
对于第一组样例，小$w$可以赢得前四局 $(2>1,3>2,4>3,5>4)$，输掉最后一局。注意如果小w按$1,2,3,4,5$的顺序出牌，他会输掉所有比赛。
对于第二组样例，小$w$可以赢得前三局。可以证明这是赢得三局的情况下字典序最大的出牌顺序。

### 题解

考虑贪心，根据小c的出牌顺序，对于后出的牌，小w在得分的条件下尽量出小的没出过的牌；如果不能得分就出没用过的最小的牌。这样是最优的，因为如果可以得分就在得分的前提下，让大的牌尽量在后面出肯定比先出更优。这样就求出了一种得分最多的方案。

要让字典序最大，可以用类似冒泡排序的做法，如果 $i<j$ 且 $c[i]<c[j]$ 在不影响得分的前提下交换，就得到了字典序最大的方案。

### 代码

```cpp
//贪心
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=1005;
int a[N],b[N],n,c[N];
bool used[N];
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;++i) scanf("%d",&a[i]);
    for (int i=1;i<=n;++i) scanf("%d",&b[i]);
    sort(b+1,b+1+n);
    for (int i=n;i;--i){//贪心求出一种方案
        bool flag=0;
        for (int j=1;j<=n;++j)
            if (b[j]>a[i] && !used[j]){
                c[i]=b[j],used[j]=flag=1;
                break;
            }
        if (!flag){
            for (int j=1;j<=n;++j)
                if (!used[j]){
                    used[j]=1,c[i]=b[j];
                    break;
                }
        }
    }
    for (int i=1;i<n;++i){//最优化方案
        int r=i;
        for (int j=i+1;j<=n;++j)
            if (c[j]>c[r]){
                int lst=(c[i]>a[i])+(c[j]>a[j]);
                int now=(c[i]>a[j])+(c[j]>a[i]);
                if (lst==now) r=j;
            }
        swap(c[i],c[r]);
    }
    for (int i=1;i<=n;++i) printf("%d ",c[i]);
    return 0;
}
```





## T2 小w的作业
<p style="text-align: center;font-size: 18px;font-family: consolas">空间限制：512M  时间限制：3s</p>
### 【问题描述】
小 $w$ 在上数学课，他的老师布置了一道作业题。在二维平面上有n个不同的点 $a_1,a_2,...a_n$ 。对于每一对点 $(a_i,a_j)(i<j)$ ，都有一条通过 $a_i$ 和 $a_j$ 的直线 $L_{ij}$ 。我们定义 $A_{ij}$ 为从水平线开始逆时针旋转到 $L_{ij}$ 的角度，即 $L_{ij}$ 和水平线的夹角。角度用弧度制表示。根据定义，显然 $0\leq A_{ij}<\pi$ 。对于所有的总共 $n\times (n-1)/2$ 个角度 $A_{ij}$ ，小 $w$ 想要知道它们的中位数。即设 $m=n\times (n-1)/2$ ，若 $m$ 为奇数则小 $w$ 想知道第 $(m+1)/2$ 大的角度，若 $m$ 为偶数则小 $w$ 想知道第 $m/2$ 和 $m/2+1$ 大的角度的平均数。
### 【输入文件】
第一行一个整数 $n$ ，表示点的个数。接下来 $n$ 行，每行两个整数 $x_i,y_i$ ，表示平面上的一个点。
### 【输出文件】
一个小数，即用弧度制表示的角度的中位数。当输出结果与标准输出的相对误差或绝对误差小于$1e-9$，即算正确。
### 【输入样例1】
```
3
0 0
0 1
1 0
```
### 【输出样例1】
```
1.5707963268949
```
### 【输入样例2】
```
3
0 0
1 0
2 0
```
### 【输出样例2】
```
0
```
### 【数据规模和约定】
对于 $40\%$ 的数据，保证 $n\leq 1000$
对于 $100\%$ 的数据，保证 $n\leq 5\times 10^4$
数据保证，$-10^9\leq x_i,y_i\leq 10^9$，任意两个点 $(x_i,y_i)$ 互不相同。

### 题解

因为角度在 $0$ 到 $\pi$ 之间，考虑二分角度，那么就要算出有几个角度小于 $(m+1)/2$ ,($m$ 是奇数)，或 $m/2$ ,($m$ 是偶数)。若过一对点的直线是水平线旋转了 $\theta$ 角，这条直线的斜率就等于 $tan(\theta)$ 。所以，如果二分出一个角 $\theta$ ，只需统计 $k=\frac{y_i-y_j}{x_i-x_j}\leq tan(\theta)=\frac{sin(\theta)}{cos(\theta)}$ 点对数。先不考虑正负，把式子交叉相乘 $cos(\theta)y_i-cos(\theta)y_j \leq sin(\theta)x_i-sin(\theta)x_j$ ，移项得 $cos(\theta)y_i-sin(\theta)x_i\leq cos(\theta)y_j-sin(\theta)x_j$ 。只要将每个点的 $cos(\theta)y_i-sin(\theta)x_i$ 排序，用树状数组统计对于每个点 $i$ 有几个点 $j$ 满足上述不等式即可。

但是正负情况不能忽略，我们先把第一个式子倒过来 $\frac{x_i-x_j}{y_i-y_j}?\frac{cos(\theta)}{sin(\theta)}$ 函数 $f(x)=sin(x)$ 在 $(0,\pi)$ 上大于 $0$ 所以要将坐标以 $y$ 为第一关键字排序保证 $y_i>y_j$ ，又因为 $x_i-x_j$ 和 $cos(\theta)$ 符号相同，所以不等号不用变方向。

### 代码

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=5e4;
const double eps=1e-12,pi=acos(-1);
int n,rk[N+5],c[N+5];
struct Points{
    int x,y;
}a[N+5];
struct Ang{
    double k;
    int id;
}b[N+5];
 
int lowbit(int x){
    return x&(-x);
}
 
void add(int x,int val){
    for (;x<=N;x+=lowbit(x)) c[x]+=val;
}
 
int ask(int x){
    int ans=0;
    for (;x;x-=lowbit(x)) ans+=c[x];
    return ans;
}
 
bool cmp(Points a,Points b){
    return a.y==b.y?a.x>b.x:a.y>b.y;
}
 
bool cmp2(Ang x,Ang y){
    return x.k<y.k;
}
 
long long calc(double the){
    memset(c,0,sizeof c);
    for (int i=1;i<=n;++i)
        b[i].k=a[i].y*cos(the)-a[i].x*sin(the),b[i].id=i;
    sort(b+1,b+1+n,cmp2);
    rk[b[1].id]=1;
    for (int i=2;i<=n;++i)
        if (b[i-1].k+eps>b[i].k) rk[b[i].id]=rk[b[i-1].id];
            else rk[b[i].id]=i;
    long long ans=0;
    for (int i=1;i<=n;++i){
        ans+=ask(rk[i]-1);
        add(rk[i],1);
    }
    return ans;
}
 
double solve(long long rnk){
    double l=0,r=pi;
    while (l+eps<r){
        double mid=(l+r)/2.0;
        if (calc(mid)>=rnk) r=mid;
            else l=mid;
    }
    return l;
}
 
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;++i) scanf("%d%d",&a[i].x,&a[i].y);
    sort(a+1,a+1+n,cmp);
    long long m=1LL*n*(n-1)/2;
    if (m&1) printf("%.10lf",solve((m+1)>>1));
        else printf("%.10lf",(solve(m>>1)+solve((m>>1)+1))/2.0);
    return 0;
}
```

## T3  小w学图论
<p style="text-align: center;font-size: 18px;font-family: consolas">空间限制：512M  时间限制：1s</p>
### 【问题描述】
小w这学期选了门图论课，他在学习点着色的知识。他现在得到了一张无向图，并希望在这张图上使用最多 $n$ 种颜色给每个节点染色，使得任意一条边关联的两个节点颜色不同。小w获得一张 $n$ 个节点 $m$ 条边的基图，并得到了一份神秘代码。他会根据这份代码的内容构建完整的无向图。
```cpp
while(1){
	int modify_tag=0;
	for(int x=1;x<=n;x++)
		for(int y=x+1;y<=n;y++)
			for(int z=y+1;z<=n;z++)
			if(edge(x,y)∈G && edge(x,z)∈G){
				add edge(y,z) to G
				modify_tag=1;
			}
	if(modify_tag==0) break;
}
```
即对于图上的任意三元组 $x<y<z$，若 $(x,y)$，$(x,z)$ 在图中则在图上加上一条 $(y,z)$ 的边，直至无法加边为止。小w想要知道使用 $n$ 种颜色给这张基图生成的完整无向图的染色方案数。小w太菜了，他无力解决这个难题，于是只好把它交给了你。
### 【输入文件】
第一行两个整数 $n，m$，表示点数和边数。接下来 $m$ 行，每行两个整数 $u,v(1\leq u,v\leq n)$，表示基图中存在 $(u,v)$ 这条边。
### 【输出文件】
一个整数，表示染色的方案数。鉴于答案可能很大，请输出方案数对 $998244353$ 取模的结果。
### 【输入样例1】
```
5 5
1 3
1 4
2 5
3 2
4 5
```
### 【输出样例1】
```
540
```
### 【数据规模和约定】
对于 $20\%$ 的数据，保证 $n\leq 5,m\leq n\times (n-1)/2$
对于 $60\%$ 的数据，保证 $n\leq 1000,m\leq 2000$
对于 $100\%$ 的数据，保证 $n\leq 10^5,m\leq 2\times 10^5$
数据保证初始图联通，无重边无自环

~~不会做，算了~~