# [模拟赛]2019/9/25

## T1 跳跳糖

[![un337R.png](https://s2.ax1x.com/2019/09/26/un337R.png)](https://imgchr.com/i/un337R)
[![un3BBd.png](https://s2.ax1x.com/2019/09/26/un3BBd.png)](https://imgchr.com/i/un3BBd)

### 题解

可以贪心，显然要跳的步数最少，就要径直往终点跳。如果不能刚好到终点，只需多跳一步就好了。但要注意细节，如果两点间的距离小于步长，要跳两次；还要注意开 $long\ long$ 。

### 代码



``` cpp
#include<cstdio>
#include<cmath>
using namespace std;
double sx,sy,tx,ty,d;
 
double dist(double sx,double sy,double tx,double ty){
    return sqrt((tx-sx)*(tx-sx)+(ty-sy)*(ty-sy));
}
 
int main(){
    scanf("%lf%lf%lf%lf%lf",&sx,&sy,&tx,&ty,&d);
    double D=dist(sx,sy,tx,ty);
    if (D<d){
        printf("2");
        return 0;
    }
    long long ans;
    if (1.0*((int)(D/d))*d==D) ans=D/d;
        else ans=D/d+1;
    printf("%lld",ans);
    return 0;
}
```

## T2 扛水

[![un8HZd.png](https://s2.ax1x.com/2019/09/26/un8HZd.png)](https://imgchr.com/i/un8HZd)[![un8vz8.png](https://s2.ax1x.com/2019/09/26/un8vz8.png)](https://imgchr.com/i/un8vz8)[![un8jRf.png](https://s2.ax1x.com/2019/09/26/un8jRf.png)](https://imgchr.com/i/un8jRf)

### 题解

经过一条边 $x$ 就变成 $a_1x+b_1$ ，再经过一条边又变成 $a_2a_1x+a_2b_1+b_2$ ……又因为 $x=0$ 所以最后结果就是经过最后一条边后的 $b$ ，每经过一条边 $i$ ，$b$ 就变成 $a_ib+b_i$ ，可以用 $SPFA$ ，算出最大值；因为 $a=0,-1,1$ 所以最大可能变成最小，最小可能变成最大，我们要同时记录最大和最小，就像[P4342 [IOI1998]Polygon](https://www.luogu.org/problem/P4342)要记录最大值和最小值，才能得到最优解。至于判环，只要统计作为最大值入队的次数即可。

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<stack>
using namespace std;
const int N=5010,M=1e4+10;
const long long INF=1e18;
int n,m,head[N],tot,T,MaxCnt[N],MinCnt[N];
//MaxCnt:作为最大值入队次数，MinCnt:作为最小值入队次数
long long Max[N],Min[N];//Max:最大值,Min:最小值
bool in_q[N];//是否在队列中(其实应该用队列，但会T一个点)
struct Edge{
    int to,nxt,a,b;
}edge[M];
 
void add_edge(int x,int y,int a,int b){
    edge[++tot]=(Edge){y,head[x],a,b}; head[x]=tot;
}
 
stack<int> q;
int main(){
    scanf("%d",&T);
    while (T--){
        tot=0;
        // memset(edge,0,sizeof edge);
        memset(head,0,sizeof head);
        memset(MaxCnt,0,sizeof MaxCnt);
        memset(MinCnt,0,sizeof MinCnt);
        scanf("%d%d",&n,&m);
        for (int i=1;i<=n;++i) Max[i]=-INF,Min[i]=INF;
        for (int i=1,x,y,a,b;i<=m;++i){
            scanf("%d%d%d%d",&x,&y,&a,&b);
            add_edge(x,y,a,b);
        }
        q.push(1); in_q[1]=1; Max[1]=Min[1]=0; MaxCnt[1]=MinCnt[1]=1;
        while (!q.empty()){
            int x=q.top(); q.pop(); in_q[x]=0;
            for (int i=head[x];i;i=edge[i].nxt){
                int y=edge[i].to;
                long long mx=edge[i].a*Max[x]+edge[i].b,mn=edge[i].a*Min[x]+edge[i].b;
                //更新最大最小值
                if (mx<mn) swap(mx,mn);
                if (mx>Max[y]){
                    Max[y]=mx;
                    if ((!in_q[y]) && MaxCnt[y]<=n) q.push(y),in_q[y]=1,MaxCnt[y]++;
                    if (MaxCnt[y]>n) Max[y]=INF;
                }
                if (mn<Min[y]){
                    Min[y]=mn;
                    if ((!in_q[y]) && MinCnt[y]<=n) q.push(y),in_q[y]=1,MinCnt[y]++;
                    if (MinCnt[y]>n) Min[y]=-INF;
                }
            }
        }
        if (Max[n]==-INF){
            printf("No solution\n");
            continue;
        }else if (Max[n]>1e14){
            printf("Infinity\n");
            continue;
        }
        printf("%lld\n",Max[n]);
    }
    return 0;
}
```

> 附一组数据：
>
> ```
> /* hack.in
> 8
> 2 3
> 1 1 1 -1
> 1 2 -1 -1000000000
> 2 2 -1 0
> 3 2
> 1 3 0 100
> 2 3 0 200
> 2 1
> 2 1 0 0
> 3 3
> 1 2 0 0
> 2 2 1 1
> 1 3 0 100
> 2 2
> 1 1 1 1
> 1 2 -1 100
> 2 2
> 1 1 0 100
> 1 2 1 0
> 3 3
> 1 1 -1 1000000000
> 1 2 1 1000000000
> 2 3 1 1000000000
> 2 2
> 1 1 1 -1
> 1 2 1 100
> */
>   
> /* hack.ans
> Infinity
> 100
> No solution
> 100
> 100
> 100
> 3000000000
> 100
> */
> ```
>
> 

### T3 并行程序

[![unanOK.png](https://s2.ax1x.com/2019/09/26/unanOK.png)](https://imgchr.com/i/unanOK)[![unaYlt.png](https://s2.ax1x.com/2019/09/26/unaYlt.png)](https://imgchr.com/i/unaYlt)[![unawTg.png](https://s2.ax1x.com/2019/09/26/unawTg.png)](https://imgchr.com/i/unawTg)[![unac60.png](https://s2.ax1x.com/2019/09/26/unac60.png)](https://imgchr.com/i/unac60)[![unaX7D.png](https://s2.ax1x.com/2019/09/26/unaX7D.png)](https://imgchr.com/i/unaX7D)

### 题解

dp，但是我不怎么会……看注释吧。。。

### 代码

```cpp
#include<cstdio>
using namespace std;
const int N=1005,Mod=1e9+7;
int n,m,imp1[N],imp2[N],u1[N],v1[N],u2[N],v2[N],typ1[N],typ2[N],val[26],cnt1[N],cnt2[N],f[N][N][26],dp[N][N],ans[N<<1];
/*
imp1:第一个程序每句话的优先级
imp2:第二个程序每句话的优先级
u1,v1:第一个程序的两个变量(或数值)
u2,v2:第二个程序的两个变量(或数值)
typ1:第一个程序每句话的类型
typ2:第二个程序每句话的类型
val[i]:变量i的值
dp[i][j]:第一个程序执行了i句，第二个程序执行了j句这个状态的概率
f[i][j][k]:i,j这个状态下变量k的期望
cnt1[i]:第一个程序第i句话及之前有几个print
cnt2[i]:第二个程序第i句话及之前有几个print
*/
char cmd[10],varA[10],varB[10];
 
int qpow(int x,int k){//快速幂
    int ans=1;
    for (;k;k>>=1){
        if (k&1) ans=(1LL*ans*x)%Mod;
        x=(1LL*x*x)%Mod;
    }
    return ans;
}
 
void init(){//读入，扣数据
    scanf("%d",&n);
    for (int i=1,x;i<=n;++i){
        scanf("%d%s",&imp1[i],cmd);
        cnt1[i]=cnt1[i-1];
        switch (cmd[0]){
            case 'M':
                if (cmd[3]=='1'){
                    typ1[i]=1;
                    scanf("%s%s",varA,varB);
                    u1[i]=varA[0]-'a',v1[i]=varB[0]-'a';
                }else if (cmd[3]=='2'){
                    typ1[i]=2;
                    scanf("%s%d",varA,&x);
                    u1[i]=varA[0]-'a',v1[i]=x;
                }else{
                    typ1[i]=5;
                    scanf("%s%d",varA,&x);
                    u1[i]=varA[0]-'a',v1[i]=x;
                }
                break;
            case 'A':
                typ1[i]=3;
                scanf("%s%s",varA,varB);
                u1[i]=varA[0]-'a',v1[i]=varB[0]-'a';
                break;
            case 'S':
                typ1[i]=4;
                scanf("%s%s",varA,varB);
                u1[i]=varA[0]-'a',v1[i]=varB[0]-'a';
                break;
            case 'P':
                typ1[i]=6; cnt1[i]++;
                scanf("%s",varA);
                u1[i]=varA[0]-'a';
                break;
        }
    }
    scanf("%d",&m);
    for (int i=1,x;i<=m;++i){
        scanf("%d%s",&imp2[i],cmd);
        cnt2[i]=cnt2[i-1];
        switch (cmd[0]){
            case 'M':
                if (cmd[3]=='1'){
                    typ2[i]=1;
                    scanf("%s%s",varA,varB);
                    u2[i]=varA[0]-'a',v2[i]=varB[0]-'a';
                }else if (cmd[3]=='2'){
                    typ2[i]=2;
                    scanf("%s%d",varA,&x);
                    u2[i]=varA[0]-'a',v2[i]=x;
                }else{
                    typ2[i]=5;
                    scanf("%s%d",varA,&x);
                    u2[i]=varA[0]-'a',v2[i]=x;
                }
                break;
            case 'A':
                typ2[i]=3;
                scanf("%s%s",varA,varB);
                u2[i]=varA[0]-'a',v2[i]=varB[0]-'a';
                break;
            case 'S':
                typ2[i]=4;
                scanf("%s%s",varA,varB);
                u2[i]=varA[0]-'a',v2[i]=varB[0]-'a';
                break;
            case 'P':
                typ2[i]=6; cnt2[i]++;
                scanf("%s",varA);
                u2[i]=varA[0]-'a';
                break;
        }
    }
}
 
int main(){
    init();
    dp[0][0]=1;
    for (int i=0;i<=n;++i)
        for (int j=0;j<=m;++j){
            int lst=qpow(dp[i][j],Mod-2);//逆元(我还不会TAT),到i,j这个状态的概率
            for (int k=0;k<26;++k) f[i][j][k]=(1LL*f[i][j][k]*lst)%Mod;
            if (i<n){ //转移[i,j]-->[i+1,j]
                int p=((1LL*dp[i][j]*imp1[i+1]%Mod)*qpow(imp1[i+1]+imp2[j+1],Mod-2))%Mod;//又逆元，dp[i][j]*imp1[i+1]/(imp1[i+1]+imp2[j+1])即下一句执行第一个程序的第i+1句的概率
                dp[i+1][j]=(dp[i+1][j]+p)%Mod;//转移dp[i+1][j]
                for (int k=0;k<26;++k) val[k]=f[i][j][k];//取出每个变量的期望
                switch (typ1[i+1]){//计算变量的值
                    case 1:
                        val[u1[i+1]]=val[v1[i+1]]%Mod;
                        break;
                    case 2:
                        val[u1[i+1]]=v1[i+1]%Mod;
                        break;
                    case 3:
                        val[u1[i+1]]=(val[u1[i+1]]+val[v1[i+1]])%Mod;
                        break;
                    case 4:
                        val[u1[i+1]]=((val[u1[i+1]]-val[v1[i+1]])%Mod+Mod)%Mod;
                        break;
                    case 5:
                        val[u1[i+1]]=(1LL*val[u1[i+1]]*v1[i+1])%Mod;
                        break;
                    case 6://如果是PRINT记录答案
                        ans[cnt1[i+1]+cnt2[j]]=(1LL*ans[cnt1[i+1]+cnt2[j]]+1LL*val[u1[i+1]]*p%Mod)%Mod;
                        break;
                }
                for (int k=0;k<26;++k) f[i+1][j][k]=(1LL*f[i+1][j][k]+1LL*val[k]*p)%Mod;
            }
            if (j<m){ //转移[i,j]-->[i,j+1]，与上面类似
                int p=((1LL*dp[i][j]*imp2[j+1]%Mod)*qpow(imp1[i+1]+imp2[j+1],Mod-2))%Mod;
                dp[i][j+1]=(dp[i][j+1]+p)%Mod;
                for (int k=0;k<26;++k) val[k]=f[i][j][k];
                switch (typ2[j+1]){
                    case 1:
                        val[u2[j+1]]=val[v2[j+1]]%Mod;
                        break;
                    case 2:
                        val[u2[j+1]]=v2[j+1]%Mod;
                        break;
                    case 3:
                        val[u2[j+1]]=(val[u2[j+1]]+val[v2[j+1]])%Mod;
                        break;
                    case 4:
                        val[u2[j+1]]=((val[u2[j+1]]-val[v2[j+1]])%Mod+Mod)%Mod;
                        break;
                    case 5:
                        val[u2[j+1]]=(1LL*val[u2[j+1]]*v2[j+1])%Mod;
                        break;
                    case 6:
                        ans[cnt1[i]+cnt2[j+1]]=(1LL*ans[cnt1[i]+cnt2[j+1]]+1LL*val[u2[j+1]]*p%Mod)%Mod;
                        break;
                }
                for (int k=0;k<26;++k) f[i][j+1][k]=(1LL*f[i][j+1][k]+1LL*val[k]*p%Mod)%Mod;
            }
        }
    for (int i=1,ed=cnt1[n]+cnt2[m];i<=ed;++i) printf("%d ",ans[i]);
    return 0;
}
```

